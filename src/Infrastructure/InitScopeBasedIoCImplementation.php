<?php

namespace App\Infrastructure;

use ReflectionClass;
use ReflectionMethod;
use ReflectionParameter;

class InitScopeBasedIoCImplementation
{
    public function execute()
    {
        // Защита от повторного вызова
//        if (isset(ScopeBasedResolveDependencyStrategy::$root)) {
//            return;
//        }

        $dependencies = [];

        $dependencies['Scopes.Storage'] = function () {
            return [];
        };
        $dependencies['Scopes.New'] = function (array $arguments) {
            return new RegisterNewScopeCommand($arguments[0], $arguments[1]);
        };

        $dependencies['Scopes.Current'] = function () {
            $scope = ScopeBasedResolveDependencyStrategy::currentScope();
            if ($scope !== null) {
                return $scope;
            } else {
                return ScopeBasedResolveDependencyStrategy::$defaultScope;
            }
        };

        $dependencies['Scopes.Current.Set'] = function (array $arguments) {
            return new SetCurrentScopeCommand($arguments[0]);
        };

        $dependencies['IoC.Register'] = function (array $arguments = []) {
            return new RegisterIoCDependencyCommand($arguments[0], $arguments[1]);
        };

        $dependencies['Adapter'] = function (array $arguments = []) {
            $class = $arguments[0];
            $ref = new ReflectionClass($class);
            $interfaceName = array_reverse(explode("\\", $class))[0];
            $className = 'AutoGenerated' . $interfaceName . 'Adapter';
            $path = __DIR__ . '/Generated/' . $className . '.php';
            if (!file_exists($path)) {
                $class =
                    '<?php ' . PHP_EOL . 'class ' . $className . ' implements \\' . $class;
                $body = '';
                $body .=
                    'private \\' . InversionOfControlContainer::class . ' $container;' . PHP_EOL .
                    'private object $object;' . PHP_EOL .
                    'public function __construct(object $object) {
                $this->object = $object;
                $this->container = ' . InversionOfControlContainer::class . '::getInstance();
            }';
                /**
                 * @var $methods ReflectionMethod[]
                 */
                $methods = $ref->getMethods();
                foreach ($methods as $method) {
                    $methodReturnType = $method->getReturnType()?->getName();
                    $methodParametersArray = [];
                    $methodArgumentsArray = [];
                    $methodParameters = $method->getParameters();
                    if ($methodParameters) {
                        /**
                         * @var $methods ReflectionParameter[]
                         */
                        foreach ($methodParameters as $methodParameter) {
                            $methodParametersArray[] = "\\" . $methodParameter->getType() . ' $' . $methodParameter->getName();
                            $methodArgumentsArray[] = '$' . $methodParameter->getName();
                        }
                    }
                    $methodParameters = implode(', ', $methodParametersArray);
                    $methodName = $method->getName();
                    $methodBody = PHP_EOL . "public function {$methodName} ({$methodParameters})";
                    if ($methodReturnType) {
                        $methodBody .= ": \\{$methodReturnType}";
                    }
                    $methodArguments = implode(',', $methodArgumentsArray);

                    $methodBody .= "{ return \$this->container->resolve('{$interfaceName}.{$methodName}', \$this->object";
                    if ($methodArguments) {
                        $methodBody .= ',' . $methodArguments;
                    }
                    $methodBody .= "); }";
                    $body .= $methodBody . PHP_EOL;
                }
                $class .= PHP_EOL . '{' . $body . '}';
                file_put_contents($path, $class);
            }

            require_once $path;
            return new $className($arguments[1]);
        };

        $scope = new Scope($dependencies, new LeafScope(InversionOfControlContainer::getInstance()->resolve('IoC.Default')));

        ScopeBasedResolveDependencyStrategy::$root = $scope;

        InversionOfControlContainer::getInstance()->resolve(
            'IoC.SetupStrategy',
            ScopeBasedResolveDependencyStrategy::strategy()
        )->execute();
        InversionOfControlContainer::getInstance()->resolve("Scopes.New", 'default', $scope)->execute();
    }
}